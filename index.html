<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>Canvas: Кружечки та з'єднання стрілками</title>
    <style>
        body { margin: 0; padding: 0; }
        canvas { border: 1px solid #ccc; display: block; margin: 20px auto; }
    </style>
</head>
<body>
<canvas id="myCanvas" width="800" height="600"></canvas>
<script>
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');

    let circles = [];
    let connections = [];
    let draggingCircle = null;
    let offsetX, offsetY;
    let connectionStart = null;

    // Функція для створення нового кружечка
    function createCircle(x, y) {
        const circle = {
            x: x,
            y: y,
            radius: 20,
            color: getRandomColor()
        };
        circles.push(circle);
        draw();
    }

    function drawArrow(fromX, fromY, toX, toY) {
        // Малюємо лінію
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Обчислюємо кут лінії
        const angle = Math.atan2(toY - fromY, toX - fromX);
        const headLength = 15; // збільшена довжина наконечника

        // Малюємо наконечник стрілки як трикутник
        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(
            toX - headLength * Math.cos(angle - Math.PI / 6),
            toY - headLength * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
            toX - headLength * Math.cos(angle + Math.PI / 6),
            toY - headLength * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fillStyle = ctx.strokeStyle; // або встановіть інший колір, напр. '#f00'
        ctx.fill();
    }

    // Допоміжна функція для обчислення відстані від точки (px, py) до лінійного сегмента (x1, y1) - (x2, y2)
    function pointToLineDistance(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = (len_sq !== 0) ? dot / len_sq : -1;
        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }
        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // Функція для малювання всіх кружечків і зв'язків
    function draw() {
        // Очистити canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Малюємо зв'язки (стрілки) між кружечками
        connections.forEach(conn => {
            const c1 = circles[conn.from];
            const c2 = circles[conn.to];
            if (c1 && c2) {
                drawArrow(c1.x, c1.y, c2.x, c2.y);
            }
        });

        // Малюємо кружечки
        circles.forEach(circle => {
            ctx.beginPath();
            ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
            ctx.fillStyle = circle.color;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.stroke();
        });
    }

    // Функція для отримання випадкового кольору
    function getRandomColor() {
        const letters = '0123456789ABCDEF';
        let color = '#';
        for (let i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }

    // Функція для отримання кружечка під курсором
    function getCircleAt(x, y) {
        for (let i = circles.length - 1; i >= 0; i--) {
            const circle = circles[i];
            const dx = x - circle.x;
            const dy = y - circle.y;
            if (Math.sqrt(dx * dx + dy * dy) <= circle.radius) {
                return { circle, index: i };
            }
        }
        return null;
    }

    // Обробка події mousedown
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const hit = getCircleAt(mouseX, mouseY);

        if (e.shiftKey) {
            if (hit) {
                connectionStart = hit.index;
            }
        } else {
            if (hit) {
                draggingCircle = hit.index;
                offsetX = mouseX - circles[draggingCircle].x;
                offsetY = mouseY - circles[draggingCircle].y;
            } else {
                createCircle(mouseX, mouseY);
            }
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (draggingCircle !== null) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            circles[draggingCircle].x = mouseX - offsetX;
            circles[draggingCircle].y = mouseY - offsetY;
            draw();
        }
    });

    canvas.addEventListener('mouseup', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        if (connectionStart !== null) {
            const hit = getCircleAt(mouseX, mouseY);
            if (hit && hit.index !== connectionStart) {
                connections.push({ from: connectionStart, to: hit.index });
                draw();
            }
            connectionStart = null;
        }
        draggingCircle = null;
    });

    // Обробка правого кліку для видалення ліній (стрілок)
    canvas.addEventListener('contextmenu', (e) => {
        e.preventDefault(); // Забороняємо стандартне контекстне меню
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const threshold = 5; // Поріг в 5 пікселів

        // Перевірка кожного зв'язку
        for (let i = 0; i < connections.length; i++) {
            const conn = connections[i];
            const c1 = circles[conn.from];
            const c2 = circles[conn.to];
            if (c1 && c2) {
                const distance = pointToLineDistance(mouseX, mouseY, c1.x, c1.y, c2.x, c2.y);
                if (distance < threshold) {
                    connections.splice(i, 1);
                    draw();
                    break;
                }
            }
        }
    });

    canvas.addEventListener('mouseleave', () => {
        draggingCircle = null;
        connectionStart = null;
    });

    draw();
</script>
</body>
</html>
